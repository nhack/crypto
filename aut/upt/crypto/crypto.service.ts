import {CryptoFunction} from './cryptoFunction';
import {HashFunction} from './hashFunction';
import {KeyUsage} from './keyUsage';
import {DerivedKeyAlgorithm} from './derivedKeyAlgorithm';
import {KeyFormat} from './keyFormat';
import {KeyData} from './keyData';

/**
 * The CryptoService interface represents a set of cryptographic primitives.
 */
export interface CryptoService {

    /**
     * Returns a Promise of the encrypted data corresponding to the cleartext, algorithm and key given as parameters.
     *
     * @param algo - is an object defining the encryption function to use or a DOMString, the latter being a shorthand for {"name": algo}. Supported values are:
     *  {"name": "AES-CBC", iv} where iv is an ArrayBuffer or an ArrayBufferView with 16 random bytes (these should be generated by RandomSource.getRandomValues()).
     *  {"name": "AES-CTR", counter, length}
     *  {"name": "AES-GCM", iv, additionalData, tagLength} (additionalData and tagLength are optional)
     *  {"name": "RSA-OAEP", label} (label is optional)
     * @param - key is a CryptoKey containing the key to be used for signing.
     * @param - cleartext is a ArrayBuffer or an ArrayBufferView containing the data to be encrypted, the cleartext.
     *
     * @return - result is a Promise that returns the ciphertext generated by the encryption of the cleartext as an ArrayBuffer.
     */
    encrypt(algo: CryptoFunction, key: CryptoKey, cleartext: ArrayBuffer): Promise<ArrayBuffer>

    /**
     * Returns a Promise of the cleartext corresponding to the ciphertext, algorithm and key given as parameters.
     *
     * @param algo - is a DOMString defining the decryption function to use. Supported values are: AES-CBC, AES-CTR, AES-GCM, and RSA-OAEP.
     * @param key - is a CryptoKey containing the key to be used for decryption.
     * @param ciphertext - is a ArrayBuffer or an ArrayBufferView containing the data to be decrypted, the ciphertext.
     *
     * @return - is a Promise that returns the cleartext generated by the decryption of the ciphertext.
     */
    decrypt(algo: CryptoFunction, key: CryptoKey, ciphertext: ArrayBuffer): Promise<ArrayBuffer>

    /**
     * Returns a Promise containing the signature corresponding to the text, algorithm and key given as parameters.
     *
     * @param algo - algo is a DOMString defining the signature function to use. Supported values are: HMAC, RSASSA-PKCS1-v1_5, and ECDSA.
     * @param key - is a CryptoKey containing the private key to be used for signing.
     * @param text2sign - is a ArrayBuffer or an ArrayBufferView containing the data to be signed.
     *
     * @return - is a Promise that returns the signature on success.
     */
    sign(algo: CryptoFunction, key: CryptoKey, text2sign: ArrayBuffer): Promise<ArrayBuffer>

    /**
     * Returns a Promise of a Boolean value indicating if the signature given as parameter matches the text, algorithm and key also given as parameters.
     *
     * @param algo - is a DOMString defining the signature function to use. Supported values are: HMAC, RSASSA-PKCS1-v1_5, and ECDSA.
     * @param key - is a CryptoKey containing the key to be used to verify the signature. It is the secret key for synchronous algorithm and the public key for an asynchronous algorithm.
     * @param signature - is a ArrayBuffer or an ArrayBufferView containing the signature to verify.
     * @param text2verify - is a ArrayBuffer or an ArrayBufferView containing the data whose signature as to be verified.
     *
     * @return - is a Promise that returns a Boolean indicating if the signature has been a success on success.
     */
    verify(algo: CryptoFunction, key: CryptoKey, signature: ArrayBuffer, text2verify: ArrayBuffer): Promise<Boolean>

    /**
     * Returns a Promise of a digest generated from the hash function and text given as parameters.
     *
     * @param algo - is a DOMString defining the hash function to use. Supported values are: SHA-1, SHA-256, SHA-384, and SHA-512.
     * @param buffer - is a ArrayBuffer or an ArrayBufferView containing the data to be hashed using the hashing algorithm.
     *
     * @return - is a Promise that returns the hash on success.
     */
    digest(algo: HashFunction, buffer: ArrayBuffer): Promise<ArrayBuffer>

    /**
     * Returns a Promise of a newly generated CryptoKey, for symmetrical algorithms, or a CryptoKeyPair, containing two newly generated keys, for asymmetrical algorithm, that matches the algorithm, the usages and the extractability given as parameters.
     *
     * @param algo - is a dictionary object defining the key generation function to use. Supported algo are: AES-CBC, AES-CTR, AES-GCM, RSA-OAEP, AES-KW, HMAC, RSASSA-PKCS1-v1_5, ECDSA, ECDH, and DH.
     * @param extractable - is a Boolean indicating if the key can be extracted from the CryptoKey object at a later stage.
     * @param keyUsages - is an Array indicating what can be done with the newly generated key. Possible values of the array are:
     *  "encrypt", allowing the key to be used for encrypting messages.
     *  "decrypt", allowing the key to be used for decrypting messages.
     *  "sign", allowing the key to be used for signing messages.
     *  "verify", allowing the key to be used for verifying the signature of messages.
     *  "deriveKey", allowing the key to be used as a base key when deriving a new key.
     *  "deriveBits", allowing the key to be used as a base key when deriving bits of data for use in cryptographic primitives.
     *  "wrapKey", allowing the key to wrap a symmetric key for usage (transfer, storage) in unsecure environments.
     *  "unwrapKey", allowing the key to unwrap a symmetric key for usage (transfer, storage) in unsecure environments.
     *
     * @return - is a Promise that returns the generated key as a CryptoKey or a CryptoKeyPair.
     */
    generateKey(algo: CryptoFunction, extractable: Boolean, keyUsages: KeyUsage[]): Promise<CryptoKey>

    /**
     * Returns a Promise of a newly generated CryptoKey derivated from a master key and a specific algorithm given as parameters.
     *
     * @param algo - is an object defining the derivation algorithm to use. Supported values are:
     *  {"name": "ECDH", "public": publicKey}
     *  {"name": "DH", "public": publicKey}
     *  {"name": "PBKDF2", salt, iterations, hash} where salt is an ArrayBuffer or an ArrayBufferView, iterations is the number of iterations and hash is a DOMString identifying the hashing algorithm to use (currently only "SHA-1" is supported).
     *  {"name": "HKDF-CTR", hash, label, context}
     * @param masterKey - is a CryptoKey representing the master key to be used by the key derivation algorithm.
     * @param derivedKeyAlgo - is an object defining the algorithm the derived key will be used for or a DOMString as a shortcut for {"name": derivedKeyAlgo}. For AES a length property is also required, possible values are 128, 192 or 256 bits.
     * @param extractable - is a Boolean indicating if the key can be extracted from the CryptoKey object at a later stage.
     * @param keyUsages - is an Array indicating what can be done with the newly generated key. Possible values of the array are:
     *  "encrypt", allowing the key to be used for encrypting messages.
     *  "decrypt", allowing the key to be used for decrypting messages.
     *  "sign", allowing the key to be used for signing messages.
     *  "verify", allowing the key to be used for verifying the signature of messages.
     *  "deriveKey", allowing the key to be used as a base key when deriving a new key.
     *  "deriveBits", allowing the key to be used as a base key when deriving bits of data for use in cryptographic primitives.
     *  "wrapKey", allowing the key to wrap a symmetric key for usage (transfer, storage) in unsecure environments.
     *  "unwrapKey", allowing the key to unwrap a symmetric key for usage (transfer, storage) in unsecure environments.
     *
     * @return - is a Promise that returns the derivated key as a CryptoKey or a CryptoKeyPair.
     */
    deriveKey(algo: CryptoFunction, masterKey: CryptoKey, derivedKeyAlgo: DerivedKeyAlgorithm, extractable: Boolean, keyUsages: KeyUsage[]): Promise<CryptoKey>

    /**
     * Returns a Promise of the CryptoKey generated from the data given in parameters.
     *
     * @param format - is an enumerated value describing the data format of the key to imported. It can be one of the following:
     *  "raw", the key as an array of bytes, usually a secret key.
     *  "pkcs8" a private key, in the IETF Public Key-Cryptographic Standard Encryption #8.
     *  "spki", usually a public key, in the Simple public key infrastructure standard
     *  "jwk", the key in the JSON Web Key format.
     * @param keyData - is an ArrayBuffer or a JSONWebKey containing the key in the give format.
     * @param algo - is a DOMString defining the signature function to use. Supported values are: AES-CTR, AES-CBC, AES-GCM, RSA-OAEP, AES-KW, HMAC, RSASSA-PKCS1-v1_5, ECDSA, ECDH, DH.
     * @param extractable - is a Boolean indicating if the key can be extracted from the CryptoKey object at a later stage.
     * @param usages - is an Array indicating what can be done with the newly generated key. Possible values of the array are:
     *  "encrypt", allowing the key to be used for encrypting messages.
     *  "decrypt", allowing the key to be used for decrypting messages.
     *  "sign", allowing the key to be used for signing messages.
     *  "verify", allowing the key to be used for verifying the signature of messages.
     *  "deriveKey", allowing the key to be used as a base key when deriving a new key.
     *  "deriveBits", allowing the key to be used as a base key when deriving bits of data for use in cryptographic primitives.
     *  "wrapKey", allowing the key to wrap a symmetric key for usage (transfer, storage) in unsecure environments.
     *  "unwrapKey", allowing the key to unwrap a symmetric key for usage (transfer, storage) in unsecure environments.
     *
     * @return - is a Promise that returns the generated CryptoKey.
     */
    importKey(format: KeyFormat, keyData: KeyData, algo: CryptoFunction, extractable: Boolean, usages: KeyUsage[])
}
